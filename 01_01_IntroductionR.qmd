---
title: "An Introduction to R"
bibliography: refs.bib
engine: knitr
---
```{r echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
```

# Preliminaries
We will assume that when you are reading this you have downloaded R and have been able to access R in some way.  This may be via the command line, but most likely we imagine you will have some GUI which allows you to see a number of windows including a space for graphical output, a description of the contents of your R Environment (for example any data you have loaded), potentially a place to write your code in R, and, most importantly, a "shell", or R interface, which looks like the following:
```{bash eval = FALSE}
R 
```

```
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

>
```


Here, R code can be entered directly following a prompt which is the `>` symbol at the bottom of the window above. From the moment you open `R` you are in an `R` session until the moment you close it, from now on understand a session as this time between you open and close `R`. The most simple way to execute code in `R`is to simply input commands into your `R` console.  So, for example, you could write the following at to the right of the `>` symbol, and R will evaluate this code:

```{r}
4 + 4
```

As you can see, `R` has understood the instruction that you want to add 4 plus 4 and show the result, which is evaluated, and output directly below the code in the `R` console.  Later in this chapter we will properly explain these mathematical operations and the different `R` data types. Beyond evaluating such simple mathematical operations, R has a host of in-built functions which can be invoked at the command line.  While we will interact with this in more detail later, a simple example is the following, which you can type in your R console:

```{r}
getwd()
```

This function which can be understood as "get working directory" will show you the path on your computer where `R` is currently working.  Thus, any files saved will be exported there, and `R` will search for any thing to import from this directory. If you want to change this directory you must use the function `setwd("Path/to/the/directory/you/want/to/use")` with the path written between `" "` or `' '` in order to `R` understand that is a character, again a topic that will be seen deeper latter.  It is important to note that paths should be separated with the slash character: `/` rather than the backlash `\`, and this will work on any operating system.  Indeed, if you try to set directories with a backslash, you will see that `R` returns an error.

We will return to discuss functions in more detail a bit later on.  For now you will note that we have simply been typing instructions to `R` directly into the console, and `R` has been providing us with output.  Generally, we will not work this way in an empirical research project, as we will want to develop code over time, and be able to return to R and replicate code in the future.  For this reason, generally we will work in R scripts, or files named as `something.R` (where `something` will be logical name for the file).  We will use these scripts to store the commands which we require for particular processes or routines, and can then save them to the disk of our computer before running them in `R`.  These scripts can be generated in any type of text editor, and then can be run in `R` using the `source()` command.  For example, below, you can see a screenshot of a sessin on R Studio where we have a basic R script named `firstRscript.R`, and below this, in the R console we see that the script is run using `source` and output is provided.

![An R Script and Output in RStudio](sourceR.png)

You may notice something strange about the code and the output in the `R` console.  The R script has 7 distinct lines of text, but the console only produces two lines of output.  The reason for this is because we have included comments, or messages for human eyes, but not for the computer to interpret.  Any time that the `#` character is included in code, `R` understands that this is a comment, and hence is ignored in executing the code.  So, for example, when we write:

```{r}
print("Hello World!")
```
in our code, the `R` console correctly echoes *Hello World!* back at us.  However, if we enter precisely the same code, but begin the line with a comment symbol, `R` will not do anything given that it interprets everythin to the right of `#` as plain text which should be ignored:
```{r}
# print("Hello World")
```

Similarly, comments can be used within lines:
```{r}
print("Hello World") # To the left of # code, all to the right, plain text
```

As you can, this lines has executed the instruction to the left of `#` but ignores all those to the right.  It is good practice to comment code extensively, both for sharing code with other users, but also for sharing code with yourself in the future, where you may not remember precisely what you were thinking when you originally wrote your code!

One final thing to note from this `R` script is that the output from the final line of code (`4+4`) was not printed in the console.  In R, when you type `4+4` at the command line, you get immediate output because R is operating in an interactive mode. In interactive mode, R evaluates expressions as soon as you enter them and displays the result to the console.  However, when you write `4+4` in a script and then run the script, there is no automatic output to the console.  However, it is important to note that the calculation *is* conducted. You can confirm this yourself if you'd like by explicitly requesting that `R`provide this output when it runs the code, replacing `4+4` in the code with `print(4+4)`.

### An introduction to language and data types

Until now we have executed some code in `R` and seem some specific functions which print output, but we have never stored any results for later use within our code.  Generally we *will* want to store the output of intermediate steps in our code for later use.  This can be done in `R` using any of the following assignment symbols: `->`, `=` or `<-` (though `->` is generally preferred). For example, below we store a number of values as a variable which we define, arbitrarily named `x`:

```{r}
x <- 1
x
x = 2
x
3 -> x
```

With the use of `->` or `<-` the arrows make clear that we are assigning some particular value (or values) to a named variable, where the named variable is indicated by the arrow head.  However, with the use of `=` the assignment must respect `name = value`.  If, instead, we try to assign some variable as `value=name` an error will occur:

```{r error=TRUE}
4 = x
```

This error implies that the code has not been executed, and if we inspect the contents of `x` we will see that its prior value remains.
```{r}
x
```
In general, a command can produce a number of conditions which contain important messages for us.  These are:

- `Error`: These kinds of messages tell you that something has gone wrong and `R` couldn't execute your code. Usually error messages include a brief explanation of what has gone wrong, to help you diagnose and fix your code.  Any expected results from your command will not be assigned. 
- `Warning`: These kinds of message indicate that somes has occurred that could potentially cause problems, but is not critical for code execution. In these cases, `R` will still execute the code and give the result, but warn you that not everything is in order and this may cause inaccurate results or future problems. At times this messages can be ignored without further issues, but warnings can also be a sign of peril, and so time should be taken to review warnings and understand whether they are problematic.
- `Message`: This kinds of messages simply provide information about the execution of your command, and `R` is providing you with some piece of information which is useful for you to know.  This will not affect the output of your code, and does not generally indicate an error with your code.

#### Data Types
##### Text (String) Data
To get up and running with `R`, it is useful to understand the different ways which data can be stored.  `R` can hold a number of different types of objects in its working memory, and it is important that `R` understands what type of information we are passing or storing.  Among others, R allows for information to be stored as characters, numeric, arrays, data frames and lists. Different types of data allow different types of operations, and should be stored in different ways.  Characters are perhaps the conceptually simplest type of data.  Characters are simply strings of text, and should be specified between `" "`, or `' '`.  We have seen the use of characters when printing "Hello world" previously.  If characters are not indicated between strings, `R` will understand that they refer to variable names.  For example, returning to *Hello World*, if this is entered without quotes, an error will appear:

```{r error=TRUE}
Hello World
```

Indeed, if we look carefully at the error message we may see that the error has occurred when `R` arrives to *World*.  This is because it assumes that *Hello* is a variable name, but this must be followed by some valid assignment.  For example, had we written ```Hello<-"world"``` this would have been perfectly fine!  Alternatively, if we do actually want to write this as characters, we can do so simply by enclosing the text in quotes:

```{r}
"Hello World"
```

We can confirm that this is effectively understood to be character data by using the `class()` function.  This function indicates the type of data of the argument it receives, as we can see below.  Note also that if we generate some variable using the assignment operators discussed above, `class()` will return to us the type of  data that the variable contains:

```{r}
class("Hello World")
my_var <- "Hello World"
class(my_var)
```

##### Numeric Data
Numeric data is entered without any special behaviour, simply writing the number in the case of scalar values.  Indeed, if numeric data is accidentally enclosed between quotes, it will be treated as character, and *not* numeric data.  For example, below we assign two variables based on the number `2` and confirm that one is numeric while the other is viewed as a character.  

```{r}
num1<-2
num2<-"2"
class(num1)
class(num2)
```

If you try to perform numerical operations based on the above variables (more on this below), you will see that `num1` can be involved in such calculations, while `num2` cannot.

##### Vectors and Arrays
Generally, we will be dealing with more than a single number in our work, and for this reason need ways	to collect groups of numbers.  Vectors and arrays (or matrices) provide some ways to do this.  An easy way to create vectors or arrays is via the `c()` function, which stands for "combine".  This allows for numbers to be combined in a vector.  For example,
```{r}
c(1,2)
```
This is required to group numbers.  If we simply write a series of numbers without wrapping them in the `c` function, error will occur:
```{r error=TRUE}
1 2 
```
```{r error=TRUE}
1,2
```

A precaution to note here is related to mixing of data types in objects that combine different elements because different data types will influence the way this combination works. For example vectors will coerce all data to the most restrictive data type, if you mix characters with numbers in a vector, `R` will coerce the vector type to a character:

```{r}
class(c(1,2))
class(c(1,"2"))
```

This behaviour can be overruled using `as.` which allows for specific data types to be indicated.  For example, if we take the previous vector of a number and a character, we can ensure that the result is numerica as follows:
```{r}
as.numeric(c(1,"2"))
```
However, note that this does has limits if the underlying object cannot be converted to that data type! 
```{r warning=TRUE}
as.numeric(c(1,"A"))
```
In the above, the inclusion of a string which cannot be logically converted to a number implies that `R` has issued a warning and converted this element to `NA`.  `NA` is `R`'s "Not available" or missing value indentifier.  We will discuss a bit later on about how to deal with this in your programming. 


You can also create arrays with the `matrix` function, this allows you to get objects in two dimensiones, rows and columns

```{r}
matrix(c(1,2,3,4), nrow = 2)
```

It is worth noting a couple of potentially important details with these matrices.  A first point which we already have come across is related to coercion of types.  For example, if passing a vector via the matrix command, `R` will coerce the matrix to the more restrictive data type:
```{r}
matrix(c(1,2,3,"4"), nrow = 2)
```
A second, potentially more surprising behaviour is the "recycling" of values if matrices are not of the correct length.  For example, as you can see below, if we add a 5th element to the vector, this can no longer correctly fit in two rows.  So `R`'s default behaviour is to begin "recylcing" values from the beginning until the matrix is full, and so it returns to the first element of the vector and fills in the "missing" cell.  If, however, you actually want this to be an `NA` value, you need to instruct `R` about this, as in the second case below.
```{r}
matrix(c(1,2,3,4,5), nrow = 2)
matrix(c(1,2,3,4,5,NA), nrow = 2)
```


##### Data frames
Likely the type of object which we will be working with the most in our analysis in `R` are data frames.  Data frames allow us to mix mutliple other types of data, viewing the collection of variables and observations as a database with multiple rows and columns.  Within data frames, we can easily subset to certain rows (observations), columns (variables), and conduct univariate and multivariate analysis.  It will likely be the starting point for much of your work when you import a standard dataset into `R`. As an example we create a data frame named `df` that will use later in other examples:

```{r}
df <- data.frame(A = c(1, 2, 3), B = c(4, 5, 6), 
                 C = c("XXX", "YYY", "ZZZ"))
df
```
As we have entered the data frame, we have three columns named "A", "B" and "C".  Each column consists of three observations, and when the data frame is printed, we see that `R` has helpfully assigned observation numbers in the left-most side of the data frame.  Shortly we will see more about how to manipulate and work with data frames.

The last data type we will briefly introduce in this section are lists.  Lists allow us a very flexible way to group things together, allowing us to store any data type we need.  For example, as we see below in a single object we are combining characters, numbers and a data frame, all in a single "container" called a list.  The flexibility of lists to contain many data types is why many functions that we will work with later on return their results as lists or as objects created from lists.  As in data frames, in lists, each element is given its own name, and when printed are referred to by this name:

```{r}
l <- list(Character = c("Hello", "World"),
     	  Number = c(1, 2, 3, 4),
          DataFrame = df)
l
```

#### Subset Multidimensional Elements
As we saw in data frames and lists, often we will work with objects that store multiple elements. Sometimes we may want to work with a subset of this multidimensional data instead the entire object. In data frames, or lists, you can easily access an entire column, or element, by using `$` followed by the column, or object, name:

```{r}
df$A
l$Character
```

But sometimes you may want to access more, or less, than one entire column or object, so the more general way to access to the elements are with the use of `[ ]` to subset. For one dimensional objects like vectors or a column of a data frame, we can access elements by using the number of the element position between `[ ]`. For example, for a column "A" in our data frame:
```{r}
df$A[1]
```
Identical nomenclature is used for vectors.

This syntax work to access more than a single object by combining it with a vector, for example as follows to access the first and third element of `df$A`:
```{r}
df$A[c(1, 3)]
```

In the case of multidimensional elements such as an entire data frame or array you should use the `[row,column]` syntax to control subsetting. If you would like to access an entire row, this can be requested by just leaving the row position blank:
```{r}
df[,1]
```
with the same logic holding to access an entire column:
```{r}
df[1,]
```

Similarly, all of the above can be mixed to grab multiple rows or columns.

```{r}
df[2,2]
df[c(1,3), 2]
```

In lists the syntax is slightly different given the way that lists are internally stored.  In this case,  first you must access the object of interst with a double `[ ]` and then once you access the object it behaves in the same way that we saw above. For example, if we wanted to access the second row and second column of our data frame `df` stored in the list `l`, we can do so as follows, noting that the data frame is stored as the third item in the list:
```{r}
l[[3]][2,2]
```

Alternatively, between the first brackets you can also use the element's name to select it for later processing.  The following code exactly replicates the previous example, however arguably is less error prone, because it is clear precisely which elements we wish to select ("DataFrame" from the list, and column "B" from the data frame):
```{r}
l[["DataFrame"]][2,"B"]
```

#### Basic Operations
The standard mathematical operations in `R` likely work how you would expect.  Basic mathematical operations are as follows, with an example of their use below:

|   Symbol    |    Operation     |
|:-----------:|:----------------:|
|     `+`     |     Addition     |
|     `-`     |   Subtraction    |
|     `*`     |  Multiplication  |
|     `/`     |     Division     |
| `**` or `^` |      Power       |
|    `%%`     |     Modulus      |
|    `%/%`    | Integer Division |

A few examples

```{r}
10 + 3
10 - 3
10 * 3
10 / 3
10 ^ 3
10 ** 3
10 %% 3
10 %/% 3
```

Also when you combine different operators it respects the PEMDAS order, first resolving Parentheses, second solve Exponents, third Multiplication and Division, fourth Addition and Substraction.  Both multiplication and division, and addition and substraction are evaluated left to right, rather than sequentially by operation, so it is important to indicate to `R` explicitly what you need using parentheses in certain cases.  For example in order to solve $$-\frac{5 + 3^{5-3}}{5\times 3}$$ You should use the code

```{r}
-(5+3^(5-3))/(5*3)
```

Specifically in the case of matrices, mathematical operations are assumed to refer to cell by cell calculations.  If, instead, you would like to undertake matrix multiplication, this must be requested with `%*%`.  For example, consider the two operations below and why they differ, also noting the `t()` is the matrix transpose operation.
```{r}
a=matrix(c(1,2,3,4,5,6), nrow=2)
a*a
a%*%t(a)
```

`R` also has logical operatos that returns a boolean value (`TRUE` or `FALSE`, also abbreviated as `T` or `F`) pointing if the statement is true or false. This operators are:

| Symbol |     Comparison     |
|:------:|:------------------:|
|  `==`  |       Equals       |
|  `!=`  |     Difference     |
|  `>`   |      Greater       |
|  `>=`  |  Greater or Equal  |
|  `<`   |     Less than      |
|  `<=`  | Less than or Equal |
| `%in%` |    If it is in     |
|  `|`   |         Or         |
|  `&`   |        And         |

A few examples

```{r}
4 == 3
4 != 3
4 > 3
4 >= 3
4 < 3
4 <= 3
4 %in% c(1,2,3,4)
TRUE | FALSE
TRUE & FALSE
```

This boolean values are interpreted by `R` as the numbers 0 for `F` and 1 for `T`, characteristic that allows you work with them numerically and is useful when you want to check a series of conditions.

The logical and mathematical operators are useful when making operations between different objects, it can be an object of a single valur or an object with multiple values. As many software `R` came with some basic functions that make specific tasks, for example if you want to add all the values in a vector you don´t need to type one-by-one all those values, you can use the function `sum`:

```{r}
sum(df$A)
```

In order to use this functions the syntaxis in `R` is the function's name followed by parenthesis `( )` and between the parenthesis the function's arguments separated by comma `,`. To know better how a function works is always a good idea to read the help document that comes along with `R`, some that you can make with `?` symbol. For an example if you type `?sum` you will see how `sum` function works and its arguments, where you can see an argument `na.rm = FALSE`, this points that the default value of the argument is `FALSE` and if you keep reading a little forward you can see that the documentation indicates for this argument: *logical. Should missing values (including NaN) be removed?* telling you the type of value that you can use and what is the functionality. Let `x` be a vector with a *missing value* `NA`

```{r}
x <- c(1, 2, NA)
```

If you use the sum function you will get an `NA` value

```{r}
sum(x)
```

But if you use the `na.rm` argument you will get the sum of the valid values

```{r}
sum(x, na.rm = TRUE)
```

As the `sum` function, `R` comes with a lot of functions in their base environment as functions to get descriptive statistics, work with dates and others. This functions are sufficient to take along any task manually but not necesarilly optimally. There are very useful functions and data types that doesn't come with base enviroment and comes with packages.

### Managing packages

What are packages? Packages is a group of functions and data types that works within them and other functions in R, this packages contains data types definitions, variables definitions and functions that realize some specific procedures. In order to install a package you have several alternatives depending on what is the package's source, but no matter the option is the case, the procedure must be done only once in your R enviroment. Now is explained how to do it from CRAN by using the function `install.packages()` writing within `" "` the package name. As an example, in order to install `dplyr` -that is one of the most famous `R`'s packages for data manipulation- you must execute the following code:

```{r eval=FALSE}
install.packages("dplyr")
```

Now that the package is installed you doesn't need to install it again unless you want to update the package. That a package is installed doesn't mean that `R` automatically loads the package along with their functions and data types, for example if you want to use the `dplyr`'s function `mutate` to create a new variable in your data frame it will be an error if you haven't load the `dplyr` package:

```{r error=TRUE}
mutate(df, C = A + B)
```

So in order to use the package you must load it each time you open a new session with the function `library()` writing the package's name within `" "` as follows

```{r}
library(dplyr)
```

Now if you want to use the `dplyr`'s function `mutate` it will work

```{r}
mutate(df, C = A + B)
```

Is highly recommended that the load of the package be included in your script for reproducibility of your code.

A situation that you may encounter in your `R` work is that sometimes you may want to use two packages that have different functions with the same name. As an example if you see the message that `R` print when you loaded `dplyr` package this says "*The following objects are masked from 'package:stats':*" and next it points the functions `filter` and `lag`, this message means that the package `stats` -one of the automatically installed and loaded by `R`- also has functions with the names `filter` and `lag`, but when you use them `R` will use the `dplyr`'s functions. For example the next code use `dplyr`'s `lag`

```{r}
lag(df$A)
```

But in order to use the masked functions you can use the syntaxis `package::function`, following the previous example, to use `stats`'s `lag`

```{r}
stats::lag(df$A)
```

### Loading and viewing data

In this section we review how to import classical data formats as `csv`, `txt`, `excel` and `dta`. The first doesn't need specific packages to work well, but the latters do.

For `csv` and `txt` data `R` comes with the functions `read.csv`, `read.csv2`, `read.delim` and `read.delim2`. If you see the help documentation you will see that the four of them belongs to the family of the `read.table` function and has a very similar usage, being the basic usage:

```{r eval=FALSE}
read.table(file = "Path/To/Your/File.csv")
```

Note that the example is made with `csv` but is the same for `txt`. If you explore the help documentation you will notice that you can specify a variety of arguments that indicates if the first row should be taken as a header row, what is the separation between columns, the decimal separator and others.

For `excel` files you count with a variety of packages such as `readxl`, `openxlsx` and `xlsx`. Each package has their function and allows different tasks as read or write depending on the package. As this section is focused on import data, we present an example of the `readxl` package's family of functions `read_xls`, `read_xlsx` and `read_excel`

```{r eval=FALSE}
read_xlsx(path = "Path/To/Your/File.xlsx")
```

If you see the help documentation you will catch that there are a variety of arguments that allows point an specific sheet to impor, an specific range, use or not the first row as column names, between others.

Finally in order to import `dta` files the package will be `haven` and the functions `read_stata` or `read_dta`, both with the basic usage as follows

```{r eval=FALSE}
read_dta(file = "Path/To/Your/File.dta")
```

Until now all examples only import data but not store it in any object, an action that doesn't make much sense because probably you import data to work with it. Now we are going to import an internal dataset from the package `wooldridge`, that contains 115 data sets from the book "Introductory Econometrics: A Modern Approach", 7th Edition by Jeffrey Wooldridge, in order to show how manipulate this data sets

```{r}
mroz <- wooldridge::mroz
```

This dataset contains the data from T. A. Mroz (1987), "The Sensitivity of and Empirical Model of Married Women´s Hours of Work to Economic and Statistical Assumptions", Econometrica 55, 765-799.

### Tyding data

In this section we are covering how to manipulate data, specifically how to make a simple exploratory analysis and modify the data frame. Note that the dataset is imported as a data frame

```{r}
class(mroz)
```

FROM ABOVE TO INCORPORATE
Later we will introduce a data type named *tibble* that is very similar to data frames, with a few differences, and is common to work with it in the *tidyverse* that will be explained later.

Along with this section you will see the use of the `head` function, this function shows us the first rows of an object in order to prevent a data frame being totally printed. Previously we mentioned the existence of *tibbles* that are a widely used structure similar to data frames but with a few differences like don't consider rownames or don't interpret strings as factors by default. We introduce this because with the use of some functions from `dplyr` package a data frame becomes automatically a tibble. For example, consider de `mroz` data frame, if we apply the combination of `group_by` and `summarise` functions to get the mean of the number of kids with less than 6 years by labor situation of the women:

```{r}
ungroup(summarise(group_by(mroz, inlf), meankidslt6 = mean(kidslt6)))
```

As you can see the result is a tibble. Now that you have an example of the use of `dplyr` you can see how easily is to get confused by using too many functions at once, a really nice operator that comes with `dplyr` is the pipe operator `%>%` that allows to apply functions without writing all together. As an example the next code replicates the previous example:

```{r}
mroz %>% group_by(inlf) %>% summarise(meankidslt6 = mean(kidslt6)) %>%
  ungroup()
```

Note that this works as: to the object at the left of the pipe operator, apply the function to the right. Another thing you can note is the use of the `group_by`, `summarise` and `ungroup` combo, where `group_by` as the name says allows to group by the variable(s) indicated, `summarise` calculate a descriptive statistic that can be `mean`, `sd`, `min`, `max`, `median`, `quantile` and others, in order to know them all you should consult the help documentation of `summarise` function.

Other functionalities of `dplyr` package are the use of `sql` functions like `sql_join` that allows to merge two data frames or tibbles, apply functions to every column or specific ones, among others. Another famous package for data manipulation is `tidyverse`, a package that comes along with other package as `dplyr`, `tibble`, `tidyr` and others like `ggplot2` for plots, `lubridate` for dates, `stringr` for strings. This fact became `tidyverse` as one of the must have package for data manipulation but with the caution that it takes up more memory.

```{r}
library(tidyverse)
```

Once loaded `tidyverse` package, you can use all the tools in the packages that are loaded with `tidyverse`. So let's now try to make a join between two data frames (tibbles), first create the mean as previous examples and next join this mean to the mroz dataset by the column inlf

```{r}
mroz %>% group_by(inlf) %>% summarise(MeanKidslt6 = mean(kidslt6)) %>%
  ungroup() %>% right_join(mroz, by = "inlf")
```

Note that the result of this procedure hasn't been store in any object, so it can't be accessed later. Other convenient tools that you will apply on this book are selecting some rows or some columns from the dataset, from `filter` function we can filter rows that meet certain condition and from the use of `select` we can filter specific columns:

```{r}
mroz %>% select(kidslt6, hours) %>% filter(kidslt6 > 2)
```

In previous section has been shown the use of `mutate` function to create new variables, in tibbles as in data frames the use of `$` operator also creates new variables:

```{r}
mroz$exper2 <- mroz$exper^2
head(mroz)
```

Another function to create variables is `transmute`, but this function doesn't mantain old variables, in fact it replace all the data for the new one

```{r}
head(mroz %>% transmute(expersquared = exper^2))
```

```{r echo=FALSE}
rm(list = setdiff(ls(), "mroz"))
```

So it must be used with caution. Finally the last tool that we introduce for data manipulation is transform data from wide format to long format and reverse. Consider the next data frame

```{r}
Data <- data.frame(Zone = c("A", "A", "B", "B"), 
                   Year = c(2021, 2022, 2021, 2022),
                   Sales = c(100, 115, 98, 106))
Data
```

This format is the long format, you have multiple observations for one unit (zone in this example), to transform it in wide format

```{r}
Data = pivot_wider(data = Data, id_cols = Zone, names_from = Year,
                   values_from = Sales)
Data
```

As you can see now there is one observation per unit. Lets get it back to long format

```{r}
Data = pivot_longer(data = Data, names_to = "Year", values_to = "Sales",
                    cols = -Zone)
Data
```

Now that you know the basics of data manipulation, the next step is to learn how make some basic plots.

```{r echo=FALSE}
rm(list = setdiff(ls(), "mroz"))
```

### Basic Plots

The basic function to make a plot in `R` is the plot function, this function maps pairs of points in the $(x,y)$ coordinate axis. Let $x$ be a sequence of integers between -5 and 5

```{r}
x <- -5:5
```

Now consider $y = x^2$

```{r}
y = x^2
```

`plot` function by default maps a point plot

```{r}
plot(x,y)
```

If you access help documentation for plot you can see how add elements to the graph

```{r}
plot(x,y, type = "l", main = "Plot Example", xlab = "Variable X",
     ylab = "Variable Y")
```

A widely used package for make more custom graphs is `ggplot2`, as `tidyverse` has been loaded previous, in this case we don't need to load `ggplot2`, but if you haven't load it remember that with the next code you can do it

```{r}
library(ggplot2)
```

The first step in `ggplot` is to define the plot

```{r}
ggplot()
```

This define a blank canvas where you can add elements, as an example a line object (*geom*) is added

```{r}
ggplot() + geom_line()
```

Until now we haven't added data so `ggplot2` is not mapping any pair of points, now specify the data, this must be done inside the `aes` function

```{r}
ggplot() + geom_line(aes(x = x, y = y))
```

Note that in order to add elements to the graph we have been using `+` unlike when using multiple variables where were used the pipe operator `%>%`. With this syntax you can add more elements to the graph

```{r}
ggplot() + geom_line(aes(x , y)) + geom_point(aes(x, y))
```

When you use a data frame you can also define `aes` inside `ggplot` function

```{r warning=FALSE}
ggplot(mroz, aes(x = exper, y = lwage)) + geom_point()
```

Here you can manipulate different overall themes for your plot and elements characteristics such as color or size

```{r warning=FALSE}
ggplot(mroz, aes(x = exper, y = lwage)) + geom_point(color = "red") +
  theme_minimal()
```

In this way you can add a variety of elements such as an OLS regression line

```{r warning=FALSE}
ggplot(mroz, aes(x = exper, y = lwage)) + geom_point(color = "red") +
  theme_minimal() + geom_smooth(method = "lm", color = "blue")
```

As said before, this introductory section of this chapter doesn't intend to be a comprehensive tutorial of `R`, instead is a wide general guide to understand some fundamentals you will see in the rest of the chapter.
